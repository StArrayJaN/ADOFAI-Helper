/* DO NOT EDIT THIS FILE - it is machine generated */
/* Header for class Level */
/*
 * Class:     Level
 * Method:    clickKey
 * Signature: (I)V
 */
#include <jni.h>
#include <windows.h>
#include <iostream>
#include <vector>
#include <stdio.h>
#include <thread>
#include <algorithm>
#include <WinUser.h>
#include <iostream>
#include <string>
#include <condition_variable>
#include <mutex>
#include <queue>
#include <memory>
#include <thread>

using namespace std;

#ifdef _MSC_VER
#pragma comment(lib, "User32.lib")
#endif

#define KEY_DOWN(key) ((GetAsyncKeyState(key) & 0x8000) ? 1 : 0)

template <class T, class Container = std::queue<T>>
class ThreadSafeQueue
{
public:
    ThreadSafeQueue() = default;

    template <class Element>
    void Push(Element &&element)
    {
        // std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(std::forward<Element>(element));
        not_empty_cv_.notify_one();
    }

    void WaitAndPop(T &t)
    {
        std::unique_lock<std::mutex> lock(mutex_);
        not_empty_cv_.wait(lock, [this]()
                           { return !queue_.empty(); });

        t = std::move(queue_.front());
        queue_.pop();
    }

    std::shared_ptr<T> WaitAndPop()
    {
        std::unique_lock<std::mutex> lock(mutex_);
        not_empty_cv_.wait(lock, [this]()
                           { return !queue_.empty(); });

        std::shared_ptr<T> t_ptr = std::make_shared<T>(queue_.front());
        queue_.pop();

        return t_ptr;
    }

    bool TryPop(T &t)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty())
        {
            return false;
        }

        t = std::move(queue_.front());
        queue_.pop();

        return true;
    }

    std::shared_ptr<T> TryPop()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty())
        {
            return std::shared_ptr<T>();
        }

        t = std::move(queue_.front());
        std::shared_ptr<T> t_ptr = std::make_shared<T>(queue_.front());
        queue_.pop();

        return t_ptr;
    }

    bool IsEmpty() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return queue_.empty();
    }

private:
    ThreadSafeQueue(const ThreadSafeQueue &) = delete;
    ThreadSafeQueue &operator=(const ThreadSafeQueue &) = delete;
    ThreadSafeQueue(ThreadSafeQueue &&) = delete;
    ThreadSafeQueue &operator=(ThreadSafeQueue &&) = delete;

private:
    Container queue_;

    std::condition_variable not_empty_cv_;
    mutable std::mutex mutex_;
};

void simulateKeyPress(int keyCode);
void sleep(double mil);
void keyPressThread(ThreadSafeQueue<int> *keyQueue);
int packInt(int low, int high);
template <typename T, class = typename std::enable_if_t<!std::is_unsigned_v<T>>>
inline typename std::make_unsigned_t<T> mabs(T _val);

extern "C" JNIEXPORT void JNICALL Java_thercn_adofai_helper_Level_start(JNIEnv *env, jclass clazz, jdoubleArray valuesObj)
{
    jsize numValues = env->GetArrayLength(valuesObj);

    jdouble *noteTime = env->GetDoubleArrayElements(valuesObj, nullptr);

    std::vector<std::tuple<double, int, bool>> keyEvents;

    const char usedKeys[] = "ABCDEFGHIJKLMN";
    const int totalKeyCount = strlen(usedKeys);
    for (unsigned i = 0; i < numValues; i++)
    {
        // as nano time
        keyEvents.push_back(std::tuple<double, int, bool>{noteTime[i] * 1000000, usedKeys[i % totalKeyCount], true});
        /* keyEvents.push_back(std::tuple<double, int, bool>{noteTime[i] + 30, usedKeys[i % totKeyCount], false}); */
    }
    std::sort(keyEvents.begin(), keyEvents.end());

    while (!KEY_DOWN(VK_SPACE))
    {
        ;
    }
    while (!KEY_DOWN('W'))
    {
        ;
    }

    auto keyStatus = 0;
    auto currentTime = 0.0;
    auto nextTime = 0.0;
    auto offsetTime = 0.0;
    auto beforeTime = std::chrono::high_resolution_clock().now();
    unsigned eventNumber = 1;

    auto afterTime = beforeTime;
    auto timeNanoseconds = 0;
    auto delayTime = 0.0;
    ThreadSafeQueue<int> *keyQueue = new ThreadSafeQueue<int>();

    thread keyPressThreadInstance(keyPressThread, keyQueue); // 子线程
    keyPressThreadInstance.detach();

    while (true)
    {
        if (eventNumber >= keyEvents.size())
        {
            break;
        }

        afterTime = std::chrono::high_resolution_clock().now();
        timeNanoseconds = std::chrono::duration<double, std::nano>(afterTime - beforeTime).count();
        currentTime += timeNanoseconds;
        beforeTime = afterTime;
        delayTime = currentTime - nextTime;

        if (delayTime < offsetTime)
        {
            continue;
        }

        // pack low bit
        keyQueue->Push(packInt(2, std::get<1>(keyEvents[eventNumber])));
        keyQueue->Push(packInt(1, std::get<1>(keyEvents[eventNumber - 1])));

        eventNumber++;
        

        offsetTime = -mabs((int)delayTime);
        nextTime = std::get<0>(keyEvents[eventNumber]) + offsetTime;

        if (offsetTime > 250000)
        {
            offsetTime = 0;
        }

        afterTime = std::chrono::high_resolution_clock().now();
        timeNanoseconds = std::chrono::duration<double, std::nano>(afterTime - beforeTime).count();
        currentTime += timeNanoseconds;
        beforeTime = afterTime;

        // std::cout << eventNumber << nextTime << currentTime << " time: " << offsetTime << std::endl;

        // sleep(0.001);
    }

    keyQueue->Push(packInt(3, 0));

    keyEvents.shrink_to_fit();

    delete keyQueue;
    keyQueue = nullptr;

    env->ReleaseDoubleArrayElements(valuesObj, noteTime, 0);
}

void simulateKeyPress(int keyCode)
{
    keybd_event(keyCode, 0, 0, 0);               // 模拟按下按键
    keybd_event(keyCode, 0, KEYEVENTF_KEYUP, 0); // 模拟释放按键
}

int packInt(int low, int high)
{
    return (high << 16) | low;
}

template <typename T, class = typename std::enable_if_t<!std::is_unsigned_v<T>>>
inline typename std::make_unsigned_t<T> mabs(T _val)
{
    const T mask = _val >> (sizeof(T) * 8 - 1);
    return (_val ^ mask) - mask;
}

void sleep(double mil)
{
    auto startTime = std::chrono::steady_clock().now();
    while (true)
    {
        auto curTime = std::chrono::steady_clock().now();
        double duration = std::chrono::duration<double>(curTime - startTime).count();
        if (duration * 1000 >= mil)
        {
            break;
        }
    }
}

void keyPressThread(ThreadSafeQueue<int> *keyQueue)
{
    while (true)
    {
        auto status = 0;

        keyQueue->WaitAndPop(status);

        auto low = status & 0x000000ff;
        auto high = status >> 8;
        if (low == 3)
        {
            break;
        }

        if (low == 1)
        {
            keybd_event(high, 0, KEYEVENTF_KEYUP, 0);
        }
        else if (low == 2)
        {
            keybd_event(high, 0, 0, 0);
        }
    }
}
